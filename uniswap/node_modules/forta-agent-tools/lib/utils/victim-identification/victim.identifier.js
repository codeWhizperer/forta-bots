"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImplementationAddress = void 0;
var forta_agent_1 = require("forta-agent");
var lru_cache_1 = __importDefault(require("lru-cache"));
var node_fetch_1 = __importDefault(require("node-fetch"));
var addresses_extractor_1 = __importDefault(require("./helpers/addresses.extractor"));
var constants_1 = require("./helpers/constants");
var token_info_fetcher_1 = __importDefault(require("./helpers/token.info.fetcher"));
var __1 = require("..");
var urlAndTwitter_1 = require("./helpers/urlAndTwitter");
var wrappedNativeTokens = {
    1: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    10: "0x4200000000000000000000000000000000000006",
    56: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
    137: "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270",
    43114: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
};
var restApis = {
    ethplorerKey: "",
    luabaseKey: "",
    moralisKey: "",
};
var etherscanApis = {
    1: {
        key: "",
        urlContractName: "https://api.etherscan.io/api?module=contract&action=getsourcecode",
        urlContractCreation: "https://api.etherscan.io/api?module=contract&action=getcontractcreation",
    },
    10: {
        key: "",
        urlContractName: "https://api-optimistic.etherscan.io/api?module=contract&action=getsourcecode",
        urlContractCreation: "https://api-optimistic.etherscan.io/api?module=contract&action=getcontractcreation",
    },
    56: {
        key: "",
        urlContractName: "https://api.bscscan.com/api?module=contract&action=getsourcecode",
        urlContractCreation: "https://api.bscscan.com/api?module=contract&action=getcontractcreation",
    },
    137: {
        key: "",
        urlContractName: "https://api.polygonscan.com/api?module=contract&action=getsourcecode",
        urlContractCreation: "https://api.polygonscan.com/api?module=contract&action=getcontractcreation",
    },
    250: {
        key: "",
        urlContractName: "https://api.ftmscan.com/api?module=contract&action=getsourcecode",
        urlContractCreation: "https://api.ftmscan.com/api?module=contract&action=getcontractcreation",
    },
    42161: {
        key: "",
        urlContractName: "https://api.arbiscan.io/api?module=contract&action=getsourcecode",
        urlContractCreation: "https://api.arbiscan.io/api?module=contract&action=getcontractcreation",
    },
    43114: {
        key: "",
        urlContractName: "https://api.snowtrace.io/api?module=contract&action=getsourcecode",
        urlContractCreation: "https://api.snowtrace.io/api?module=contract&action=getcontractcreation",
    },
};
var urlAndTwitterFetcher = function (protocols, tag) {
    var correctProtocols = protocols
        .filter(function (protocol) {
        var tagParts = tag.split(/[-.: ]/);
        var protocolParts = protocol[0].split("-");
        return (protocol[0] === tagParts[0].toLowerCase() ||
            protocolParts[0] === tagParts[0].toLowerCase() ||
            (tagParts[0].length > 3 && protocolParts[0].startsWith(tagParts[0].toLowerCase())));
    })
        .sort();
    return (0, urlAndTwitter_1.getWebsiteAndTwitter)(tag, correctProtocols);
};
var getLuabaseChainByChainId = function (chainId) {
    switch (Number(chainId)) {
        case 250:
            return "fantom";
        case 137:
            return "polygon";
        default:
            return "ethereum";
    }
};
var fetchLuabaseDb = function (address, chain) { return __awaiter(void 0, void 0, void 0, function () {
    var sqlQuery, options, response, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (restApis["luabaseKey"] === "")
                    return [2 /*return*/, ""];
                sqlQuery = "\n        select tag\n        from ".concat(chain, ".tags\n        where address='").concat(address, "'\n        limit 15\n      ");
                options = {
                    method: "POST",
                    headers: { "content-type": "application/json" },
                    body: JSON.stringify({
                        block: {
                            details: {
                                sql: sqlQuery,
                                parameters: {},
                            },
                        },
                        api_key: restApis["luabaseKey"],
                    }),
                };
                _b.label = 1;
            case 1:
                _b.trys.push([1, 4, , 5]);
                return [4 /*yield*/, (0, node_fetch_1.default)("https://q.luabase.com/run", options)];
            case 2: return [4 /*yield*/, (_b.sent()).json()];
            case 3:
                response = (_b.sent());
                return [2 /*return*/, response.data[0].tag];
            case 4:
                _a = _b.sent();
                return [2 /*return*/, ""];
            case 5: return [2 /*return*/];
        }
    });
}); };
// Helper function to fetch implementation address
var getStorageFallback = function (provider, address, blockNumber) { return __awaiter(void 0, void 0, void 0, function () {
    var storage, _i, _a, slot, padded;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                storage = "0x0000000000000000000000000000000000000000000000000000000000000000";
                _i = 0, _a = [
                    "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
                    "0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3",
                ];
                _b.label = 1;
            case 1:
                if (!(_i < _a.length)) return [3 /*break*/, 4];
                slot = _a[_i];
                return [4 /*yield*/, provider.getStorageAt(address, slot, blockNumber)];
            case 2:
                storage = _b.sent();
                padded = storage.replace(/^0x/, "").padStart(64, "0");
                storage = "0x" + padded;
                if (!forta_agent_1.ethers.BigNumber.from(storage.replace(/^(0x)?/, "0x")).eq(forta_agent_1.ethers.BigNumber.from(0))) {
                    return [3 /*break*/, 4];
                }
                _b.label = 3;
            case 3:
                _i++;
                return [3 /*break*/, 1];
            case 4: return [2 /*return*/, storage];
        }
    });
}); };
/*
  @OpenZeppelin's getImplementationAddress method simplified and using ethers.BigNumber instead of BigInt
  Original version here: https://github.com/OpenZeppelin/openzeppelin-upgrades/blob/master/packages/core/src/eip-1967.ts#L20
*/
var getImplementationAddress = function (provider, address, blockNumber) { return __awaiter(void 0, void 0, void 0, function () {
    //Helper function
    function parseAddress(addressString) {
        var buf = Buffer.from(addressString.replace(/^0x/, ""), "hex");
        if (!buf.subarray(0, 12).equals(Buffer.alloc(12, 0))) {
            return undefined;
        }
        var address = "0x" + buf.toString("hex", 12, 32); // grab the last 20 bytes
        return (0, __1.toChecksumAddress)(address);
    }
    //Helper function
    function parseAddressFromStorage(storage) {
        var address = parseAddress(storage);
        if (address === undefined) {
            throw new Error("Value in storage is not an address (".concat(storage, ")"));
        }
        return address;
    }
    var storage;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                storage = "0x0000000000000000000000000000000000000000000000000000000000000000";
                return [4 /*yield*/, getStorageFallback(provider, address, blockNumber)];
            case 1:
                storage = _a.sent();
                if (forta_agent_1.ethers.BigNumber.from(storage.replace(/^(0x)?/, "0x")).eq(forta_agent_1.ethers.BigNumber.from(0))) {
                    return [2 /*return*/, undefined];
                }
                return [2 /*return*/, parseAddressFromStorage(storage)];
        }
    });
}); };
exports.getImplementationAddress = getImplementationAddress;
function getContractName(provider, address, chainId, blockNumber) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, urlContractName, key, url, result, contractName, implementation, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _a = etherscanApis[chainId], urlContractName = _a.urlContractName, key = _a.key;
                    url = "".concat(urlContractName, "&address=").concat(address, "&apikey=").concat(key);
                    _c.label = 1;
                case 1:
                    _c.trys.push([1, 11, , 12]);
                    return [4 /*yield*/, (0, node_fetch_1.default)(url)];
                case 2: return [4 /*yield*/, (_c.sent()).json()];
                case 3:
                    result = (_c.sent());
                    if (result.message.startsWith("NOTOK")) {
                        console.log("block explorer error occurred; skipping contract name check for ".concat(address));
                        return [2 /*return*/, "Not Found"];
                    }
                    contractName = result.result[0].ContractName;
                    if (contractName === "") {
                        return [2 /*return*/, "Not Found"];
                    }
                    if (!contractName.toLowerCase().includes("proxy")) return [3 /*break*/, 9];
                    implementation = void 0;
                    return [4 /*yield*/, (0, exports.getImplementationAddress)(provider, address, blockNumber)];
                case 4:
                    implementation = _c.sent();
                    if (!(implementation !== undefined)) return [3 /*break*/, 7];
                    url = "".concat(urlContractName, "&address=").concat(implementation, "&apikey=").concat(key);
                    return [4 /*yield*/, (0, node_fetch_1.default)(url)];
                case 5: return [4 /*yield*/, (_c.sent()).json()];
                case 6:
                    result = (_c.sent());
                    if (result.message.startsWith("NOTOK")) {
                        console.log("block explorer error occurred; skipping contract name check for implementation address at ".concat(address));
                        return [2 /*return*/, "Not Found"];
                    }
                    contractName = result.result[0].ContractName;
                    if (contractName === "") {
                        return [2 /*return*/, "Not Found"];
                    }
                    return [2 /*return*/, contractName];
                case 7: return [2 /*return*/, "Not Found"];
                case 8: return [3 /*break*/, 10];
                case 9: return [2 /*return*/, contractName];
                case 10: return [3 /*break*/, 12];
                case 11:
                    _b = _c.sent();
                    return [2 /*return*/, "Not Found"];
                case 12: return [2 /*return*/];
            }
        });
    });
}
var getContractCreator = function (address, chainId) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, urlContractCreation, key, url, result, _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                _a = etherscanApis[chainId], urlContractCreation = _a.urlContractCreation, key = _a.key;
                url = "".concat(urlContractCreation, "&contractaddresses=").concat(address, "&apikey=").concat(key);
                _c.label = 1;
            case 1:
                _c.trys.push([1, 4, , 5]);
                return [4 /*yield*/, (0, node_fetch_1.default)(url)];
            case 2: return [4 /*yield*/, (_c.sent()).json()];
            case 3:
                result = (_c.sent());
                if (result.message.startsWith("NOTOK")) {
                    console.log("block explorer error occured; skipping contract creator check for ".concat(address));
                    return [2 /*return*/, ""];
                }
                return [2 /*return*/, result.result[0].contractCreator];
            case 4:
                _b = _c.sent();
                return [2 /*return*/, ""];
            case 5: return [2 /*return*/];
        }
    });
}); };
var VictimIdentifier = /** @class */ (function (_super) {
    __extends(VictimIdentifier, _super);
    function VictimIdentifier(provider, apiKeys) {
        var _this = _super.call(this, provider, apiKeys) || this;
        _this.getProtocols = function () { return __awaiter(_this, void 0, void 0, function () {
            var response;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, node_fetch_1.default)("https://api.llama.fi/protocols")];
                    case 1: return [4 /*yield*/, (_a.sent()).json()];
                    case 2:
                        response = (_a.sent());
                        response.forEach(function (protocol) {
                            _this.protocols.push([protocol.slug, protocol.url, protocol.twitter]);
                        });
                        return [2 /*return*/];
                }
            });
        }); };
        _this.getExploitationStageVictims = function (txEvent) { return __awaiter(_this, void 0, void 0, function () {
            var balanceChangesMap, erc20TransferEvents, events, wrappedTokenEvents, balanceChangesMapUsd, victims;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        balanceChangesMap = new Map();
                        erc20TransferEvents = txEvent.filterLog(constants_1.ERC20_TRANSFER_EVENT).filter(function (event) { return !event.args.value.eq(constants_1.ZERO); });
                        events = erc20TransferEvents;
                        if (txEvent.network in wrappedNativeTokens) {
                            wrappedTokenEvents = txEvent
                                .filterLog(constants_1.WRAPPED_NATIVE_TOKEN_EVENTS, wrappedNativeTokens[txEvent.network])
                                .filter(function (event) { return !event.args.value.eq(constants_1.ZERO); });
                            events = events.concat(wrappedTokenEvents);
                        }
                        return [4 /*yield*/, Promise.all(events.map(function (event) { return __awaiter(_this, void 0, void 0, function () {
                                var token, _a, from, to, value, isFromContract, currentEntry, isToContract, currentEntry;
                                var _b, _c;
                                return __generator(this, function (_d) {
                                    switch (_d.label) {
                                        case 0:
                                            token = event.address;
                                            _a = event.args, from = _a.from, to = _a.to, value = _a.value;
                                            if (!from) {
                                                from = wrappedNativeTokens[txEvent.network];
                                            }
                                            isFromContract = this.isContractCache.get(from);
                                            if (!(isFromContract === undefined)) return [3 /*break*/, 2];
                                            return [4 /*yield*/, this.provider.getCode(from)];
                                        case 1:
                                            isFromContract = (_d.sent()) !== "0x";
                                            if (isFromContract) {
                                                this.isContractCache.set(from, true);
                                            }
                                            _d.label = 2;
                                        case 2:
                                            // Update the balances map for 'from'
                                            if (balanceChangesMap.has(from)) {
                                                currentEntry = balanceChangesMap.get(from);
                                                currentEntry[token] = (currentEntry[token] || constants_1.ZERO).sub(value);
                                                balanceChangesMap.set(from, currentEntry);
                                            }
                                            else if (isFromContract) {
                                                balanceChangesMap.set(from, (_b = {}, _b[token] = value.mul(-1), _b));
                                            }
                                            if (!to) {
                                                to = wrappedNativeTokens[txEvent.network];
                                            }
                                            isToContract = this.isContractCache.get(to);
                                            if (!(isToContract === undefined)) return [3 /*break*/, 4];
                                            return [4 /*yield*/, this.provider.getCode(to)];
                                        case 3:
                                            isToContract = (_d.sent()) !== "0x";
                                            if (isToContract) {
                                                this.isContractCache.set(to, true);
                                            }
                                            _d.label = 4;
                                        case 4:
                                            if (balanceChangesMap.has(to)) {
                                                currentEntry = balanceChangesMap.get(to);
                                                currentEntry[token] = (currentEntry[token] || constants_1.ZERO).add(value);
                                                balanceChangesMap.set(to, currentEntry);
                                            }
                                            else if (isToContract) {
                                                balanceChangesMap.set(to, (_c = {}, _c[token] = value, _c));
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); }))];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, Promise.all(txEvent.traces.map(function (trace) { return __awaiter(_this, void 0, void 0, function () {
                                var _a, from, to, value, callType, bnValue, isFromContract, isToContract, currentEntry, currentEntry;
                                var _b, _c;
                                return __generator(this, function (_d) {
                                    switch (_d.label) {
                                        case 0:
                                            _a = trace.action, from = _a.from, to = _a.to, value = _a.value, callType = _a.callType;
                                            if (!(value && value !== "0x0" && callType === "call")) return [3 /*break*/, 5];
                                            from = forta_agent_1.ethers.utils.getAddress(from);
                                            to = forta_agent_1.ethers.utils.getAddress(to);
                                            bnValue = forta_agent_1.ethers.BigNumber.from(value);
                                            isFromContract = this.isContractCache.get(from);
                                            if (!(isFromContract === undefined)) return [3 /*break*/, 2];
                                            return [4 /*yield*/, this.provider.getCode(from)];
                                        case 1:
                                            isFromContract = (_d.sent()) !== "0x";
                                            if (isFromContract) {
                                                this.isContractCache.set(from, true);
                                            }
                                            _d.label = 2;
                                        case 2:
                                            isToContract = this.isContractCache.get(to);
                                            if (!(isToContract === undefined)) return [3 /*break*/, 4];
                                            return [4 /*yield*/, this.provider.getCode(to)];
                                        case 3:
                                            isToContract = (_d.sent()) !== "0x";
                                            if (isToContract) {
                                                this.isContractCache.set(to, true);
                                            }
                                            _d.label = 4;
                                        case 4:
                                            // Update the native token balance for the from address
                                            if (balanceChangesMap.has(from)) {
                                                currentEntry = balanceChangesMap.get(from);
                                                currentEntry["native"] = (currentEntry["native"] || constants_1.ZERO).sub(bnValue);
                                                balanceChangesMap.set(from, currentEntry);
                                            }
                                            else if (isFromContract) {
                                                balanceChangesMap.set(from, (_b = {}, _b["native"] = bnValue.mul(-1), _b));
                                            }
                                            // Update the native token balance for the to address
                                            if (balanceChangesMap.has(to)) {
                                                currentEntry = balanceChangesMap.get(to);
                                                currentEntry["native"] = (currentEntry["native"] || constants_1.ZERO).add(bnValue);
                                                balanceChangesMap.set(to, currentEntry);
                                            }
                                            else if (isToContract) {
                                                balanceChangesMap.set(to, (_c = {}, _c["native"] = bnValue, _c));
                                            }
                                            _d.label = 5;
                                        case 5: return [2 /*return*/];
                                    }
                                });
                            }); }))];
                    case 2:
                        _a.sent();
                        // Remove empty records
                        balanceChangesMap.forEach(function (record, key) {
                            Object.keys(record).forEach(function (token) {
                                if (record[token].eq(constants_1.ZERO)) {
                                    delete record[token];
                                }
                            });
                            if (Object.keys(record).length === 0) {
                                balanceChangesMap.delete(key);
                            }
                        });
                        balanceChangesMapUsd = new Map();
                        // Get the USD value of the balance changes
                        return [4 /*yield*/, Promise.all(Array.from(balanceChangesMap.entries()).map(function (_a) {
                                var key = _a[0], record = _a[1];
                                return __awaiter(_this, void 0, void 0, function () {
                                    var usdRecord;
                                    var _this = this;
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0:
                                                usdRecord = {};
                                                return [4 /*yield*/, Promise.all(Object.keys(record).map(function (token) { return __awaiter(_this, void 0, void 0, function () {
                                                        var UsdValue;
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0: return [4 /*yield*/, this.getValueInUsd(txEvent.blockNumber, txEvent.network, record[token].toString(), token)];
                                                                case 1:
                                                                    UsdValue = _a.sent();
                                                                    usdRecord[token] = UsdValue;
                                                                    return [2 /*return*/];
                                                            }
                                                        });
                                                    }); }))];
                                            case 1:
                                                _b.sent();
                                                balanceChangesMapUsd.set(key, usdRecord);
                                                return [2 /*return*/];
                                        }
                                    });
                                });
                            }))];
                    case 3:
                        // Get the USD value of the balance changes
                        _a.sent();
                        victims = [];
                        balanceChangesMapUsd.forEach(function (record, address) {
                            var sum = Object.values(record).reduce(function (acc, value) {
                                return acc + value;
                            }, 0);
                            // If the sum of the values is less than -100 USD, add the address to the victims list
                            if (sum < -100) {
                                var confidence = _this.getExploitationStageConfidenceLevel(sum * -1, "usdValue");
                                victims.push({ address: address, confidence: confidence });
                            }
                        });
                        // For tokens with no USD value fetched, check if the balance change is greater than 5% of the total supply
                        return [4 /*yield*/, Promise.all(Array.from(balanceChangesMapUsd.entries()).map(function (_a) {
                                var address = _a[0], record = _a[1];
                                return __awaiter(_this, void 0, void 0, function () {
                                    var _this = this;
                                    return __generator(this, function (_b) {
                                        return [2 /*return*/, Promise.all(Object.keys(record).map(function (token) { return __awaiter(_this, void 0, void 0, function () {
                                                var usdValue, value, totalSupply, threshold, absValue, percentage, confidence;
                                                return __generator(this, function (_a) {
                                                    switch (_a.label) {
                                                        case 0:
                                                            usdValue = record[token];
                                                            if (!(usdValue === 0)) return [3 /*break*/, 2];
                                                            value = balanceChangesMap.get(address);
                                                            if (!value[token].isNegative()) return [3 /*break*/, 2];
                                                            return [4 /*yield*/, this.getTotalSupply(txEvent.blockNumber, token)];
                                                        case 1:
                                                            totalSupply = _a.sent();
                                                            threshold = totalSupply.div(20);
                                                            absValue = value[token].mul(-1);
                                                            if (absValue.gt(threshold)) {
                                                                percentage = void 0;
                                                                try {
                                                                    percentage = absValue.mul(100).div(totalSupply).toNumber();
                                                                }
                                                                catch (_b) {
                                                                    percentage = 100;
                                                                }
                                                                confidence = this.getExploitationStageConfidenceLevel(percentage, "totalSupply");
                                                                victims.push({ address: address, confidence: confidence });
                                                            }
                                                            _a.label = 2;
                                                        case 2: return [2 /*return*/];
                                                    }
                                                });
                                            }); }))];
                                    });
                                });
                            }))];
                    case 4:
                        // For tokens with no USD value fetched, check if the balance change is greater than 5% of the total supply
                        _a.sent();
                        return [2 /*return*/, victims];
                }
            });
        }); };
        // Get the number of occurences of the victims in previously deployed contracts code
        _this.getVictimOccurences = function (txEvent) { return __awaiter(_this, void 0, void 0, function () {
            var chainId, blockNumber, blockNumberRange, startingCursor, retries, preparationStageAlerts, error_1, maxOccurrences, victim;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        chainId = txEvent.network, blockNumber = txEvent.blockNumber;
                        if (!this.init) {
                            this.init = true;
                            blockNumberRange = {
                                startBlockNumber: 0,
                                endBlockNumber: blockNumber - 1,
                            };
                        }
                        else {
                            blockNumberRange = {
                                startBlockNumber: blockNumber - 1,
                                endBlockNumber: blockNumber - 1,
                            };
                        }
                        retries = 5;
                        _a.label = 1;
                    case 1:
                        if (!((!startingCursor || startingCursor.blockNumber > 0) && retries > 0)) return [3 /*break*/, 6];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, (0, forta_agent_1.getAlerts)({
                                botIds: constants_1.PREPARATION_BOT,
                                chainId: chainId,
                                blockNumberRange: blockNumberRange,
                                first: 4000,
                                startingCursor: startingCursor,
                            })];
                    case 3:
                        preparationStageAlerts = _a.sent();
                        // Loop through the preparation stage alerts, and extract the addresses contained in the metadata
                        preparationStageAlerts.alerts.forEach(function (alert) {
                            if (alert.metadata) {
                                var values = Object.values(alert.metadata);
                                var victimContracts = values.filter(function (value) { return value.startsWith("0x"); });
                                victimContracts.forEach(function (victim) {
                                    _this.victimOccurrences[victim] = _this.victimOccurrences[victim] ? ++_this.victimOccurrences[victim] : 1;
                                });
                            }
                        });
                        startingCursor = preparationStageAlerts.pageInfo.endCursor;
                        return [3 /*break*/, 5];
                    case 4:
                        error_1 = _a.sent();
                        // Decrement the number of retries left
                        retries--;
                        // If retries is greater than 0, retry the operation
                        if (retries > 0) {
                            return [3 /*break*/, 1];
                        }
                        return [3 /*break*/, 5];
                    case 5: return [3 /*break*/, 1];
                    case 6:
                        maxOccurrences = 0;
                        for (victim in this.victimOccurrences) {
                            if (this.victimOccurrences[victim] > maxOccurrences) {
                                maxOccurrences = this.victimOccurrences[victim];
                            }
                        }
                        this.maxOccurrences = maxOccurrences;
                        return [2 /*return*/, this.victimOccurrences];
                }
            });
        }); };
        _this.getPreparationStageConfidenceLevels = function (victims) {
            // Create an object to store the confidence levels for each victim
            var confidenceLevels = {};
            // Loop through the victims
            for (var victim in victims) {
                /*
                  Calculate Confidence Level based on the number of occurrences of the victim address in previously deployed contracts
                  If the number of occurrences is equal to or greater than the maximum number of occurrences divided by 4 (this.maxOccurrences/4), the Confidence Level is 0.
                  Otherwise, the Confidence Level is calculated by dividing the number of occurrences by the maximum number of occurrences (divided by 4)
                  and then subtracting the result from 1.
                  The resulting Confidence Level is then multiplied by 10 and divided by 10, which has the effect of rounding the value to the nearest tenth.
                  The final Confidence Level will be a number between 0 and 1, with 0.1 increments (e.g. 0.1, 0.2, 0.3, etc.)
                 */
                var confidenceLevel = Math.round((1 - victims[victim] / (_this.maxOccurrences / 4)) * 10) / 10;
                // Ensure that the confidence level is never less than 0
                confidenceLevel = Math.max(confidenceLevel, 0);
                // Store the confidence level in the confidenceLevels object
                confidenceLevels[victim] = confidenceLevel;
            }
            // Return the confidenceLevels object
            return confidenceLevels;
        };
        _this.getExploitationStageConfidenceLevel = function (value, method) {
            // "value" is either the USD value or the percentage of total supply
            if (method === "usdValue") {
                /*
                  Calculate Confidence Level based on USD value.
                  If the value is MAX_USD_VALUE or more, the Confidence Level is 1.
                  Otherwise, the Confidence Level is calculated by:
                   - Dividing the value by the maximum value (MAX_USD_VALUE)
                   - Dividing the result by 10, which splits the range into 10 parts
                   - Rounding the result to the nearest tenth
                   - Dividing the result by 10, which scales the value down by a factor of 10 (range 0-1)
                  The resulting Confidence Level will be a number between 0 and 1, with 0.1 increments (e.g. 0.1, 0.2, 0.3, etc.)
                */
                var level = Math.round(value / (constants_1.MAX_USD_VALUE / 10)) / 10;
                return Math.min(1, level);
            }
            else if (method === "totalSupply") {
                if (value >= 30) {
                    return 1;
                }
                else if (value >= 20) {
                    return 0.9;
                }
                else if (value >= 10) {
                    return 0.8;
                }
                else if (value >= 5) {
                    return 0.7;
                }
            }
        };
        _this.identifyVictims = function (provider, victims, chainId, blockNumber) { return __awaiter(_this, void 0, void 0, function () {
            var identifiedVictims, chain, _loop_1, _i, victims_1, victim;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        identifiedVictims = {};
                        chain = getLuabaseChainByChainId(chainId);
                        _loop_1 = function (victim) {
                            var result;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4 /*yield*/, (function () { return __awaiter(_this, void 0, void 0, function () {
                                            var tag, contractCreator, protocolUrl, protocolTwitter, holders, _a, _b;
                                            var _c, _d;
                                            return __generator(this, function (_e) {
                                                switch (_e.label) {
                                                    case 0:
                                                        tag = "";
                                                        return [4 /*yield*/, fetchLuabaseDb(victim.toLowerCase(), chain)];
                                                    case 1:
                                                        // Attempt to fetch the tag from the Luabase database
                                                        tag = _e.sent();
                                                        if (!!tag) return [3 /*break*/, 7];
                                                        return [4 /*yield*/, getContractCreator(victim.toLowerCase(), chainId)];
                                                    case 2:
                                                        contractCreator = _e.sent();
                                                        if (!contractCreator) return [3 /*break*/, 4];
                                                        return [4 /*yield*/, fetchLuabaseDb(contractCreator, chain)];
                                                    case 3:
                                                        tag = _e.sent();
                                                        // If the tag ends with "Deployer", extract the name before the colon
                                                        if (tag.endsWith("Deployer")) {
                                                            tag = tag.split(":")[0];
                                                        }
                                                        _e.label = 4;
                                                    case 4:
                                                        if (!!tag) return [3 /*break*/, 7];
                                                        return [4 /*yield*/, this.getSymbolOrName(chainId, blockNumber, victim.toLowerCase())];
                                                    case 5:
                                                        // If the tag is still not found, try to fetch it using the ERC20 'symbol' or 'name' methods
                                                        tag = _e.sent();
                                                        if (!(tag === "Not Found")) return [3 /*break*/, 7];
                                                        return [4 /*yield*/, getContractName(provider, victim, chainId, blockNumber)];
                                                    case 6:
                                                        tag = _e.sent();
                                                        _e.label = 7;
                                                    case 7:
                                                        // Skip the victim if it is a known false positive
                                                        if (tag.startsWith("MEV") ||
                                                            tag.startsWith("Null") ||
                                                            tag.startsWith("Fund") || // 0xa294cca691e4c83b1fc0c8d63d9a3eef0a196de1
                                                            tag.split(" ").includes("Exploiter")) {
                                                            return [2 /*return*/];
                                                        }
                                                        protocolUrl = "";
                                                        protocolTwitter = "";
                                                        holders = [];
                                                        if (!(tag !== "Not Found" && tag !== "")) return [3 /*break*/, 12];
                                                        _c = urlAndTwitterFetcher(this.protocols, tag), protocolUrl = _c[0], protocolTwitter = _c[1];
                                                        if (!(protocolUrl === "" && protocolTwitter === "")) return [3 /*break*/, 9];
                                                        _a = urlAndTwitterFetcher;
                                                        _b = [this.protocols];
                                                        return [4 /*yield*/, this.getName(blockNumber, victim.toLowerCase())];
                                                    case 8:
                                                        _d = _a.apply(void 0, _b.concat([_e.sent()])), protocolUrl = _d[0], protocolTwitter = _d[1];
                                                        _e.label = 9;
                                                    case 9:
                                                        if (!(Number(chainId) === 1)) return [3 /*break*/, 11];
                                                        return [4 /*yield*/, this.getHolders(victim, tag)];
                                                    case 10:
                                                        holders = _e.sent();
                                                        _e.label = 11;
                                                    case 11: return [3 /*break*/, 13];
                                                    case 12:
                                                        if (tag === "Not Found") {
                                                            tag = "";
                                                        }
                                                        _e.label = 13;
                                                    case 13: return [2 /*return*/, {
                                                            protocolUrl: protocolUrl,
                                                            protocolTwitter: protocolTwitter,
                                                            tag: tag,
                                                            holders: holders,
                                                        }];
                                                }
                                            });
                                        }); })()];
                                    case 1:
                                        result = _b.sent();
                                        if (result !== undefined) {
                                            identifiedVictims[victim] = result;
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        };
                        _i = 0, victims_1 = victims;
                        _a.label = 1;
                    case 1:
                        if (!(_i < victims_1.length)) return [3 /*break*/, 4];
                        victim = victims_1[_i];
                        return [5 /*yield**/, _loop_1(victim)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, identifiedVictims];
                }
            });
        }); };
        _this.getIdentifiedVictims = function (txEvent) { return __awaiter(_this, void 0, void 0, function () {
            var chainId, blockNumber, _a, extractedAddresses, sortedRecord, _i, _b, victim, sortedPreparationStageVictims, exploitationStageVictims, preparationStageConfidenceLevels, preparationStageVictimsWithConfidence, preparationStageIdentifiedVictims, victim, exploitationStageIdentifiedVictims, filteredExploitationStageVictims, exploitationStageVictimsWithConfidence, _c, filteredExploitationStageVictims_1, victim;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        chainId = txEvent.network, blockNumber = txEvent.blockNumber;
                        if (!(blockNumber !== this.latestBlockNumber)) return [3 /*break*/, 2];
                        _a = this;
                        return [4 /*yield*/, this.getVictimOccurences(txEvent)];
                    case 1:
                        _a.victimOccurrences = _d.sent();
                        this.latestBlockNumber = blockNumber;
                        _d.label = 2;
                    case 2: return [4 /*yield*/, this.addressesExtractor.extractAddresses(txEvent)];
                    case 3:
                        extractedAddresses = _d.sent();
                        sortedRecord = {};
                        for (_i = 0, _b = Array.from(extractedAddresses); _i < _b.length; _i++) {
                            victim = _b[_i];
                            sortedRecord[victim] = this.victimOccurrences.hasOwnProperty(victim) ? this.victimOccurrences[victim] : 0;
                        }
                        sortedPreparationStageVictims = Object.fromEntries(Object.entries(sortedRecord).sort(function (a, b) { return a[1] - b[1]; }));
                        return [4 /*yield*/, this.getExploitationStageVictims(txEvent)];
                    case 4:
                        exploitationStageVictims = _d.sent();
                        preparationStageConfidenceLevels = this.getPreparationStageConfidenceLevels(sortedPreparationStageVictims);
                        preparationStageVictimsWithConfidence = {};
                        return [4 /*yield*/, this.identifyVictims(this.provider, Object.keys(sortedPreparationStageVictims), chainId, blockNumber)];
                    case 5:
                        preparationStageIdentifiedVictims = _d.sent();
                        // Add confidence property to the preparation stage victims objects
                        for (victim in preparationStageConfidenceLevels) {
                            preparationStageVictimsWithConfidence[victim] = __assign(__assign({}, preparationStageIdentifiedVictims[victim]), { confidence: preparationStageConfidenceLevels[victim] });
                        }
                        return [4 /*yield*/, this.identifyVictims(this.provider, exploitationStageVictims.map(function (victim) { return victim.address; }), chainId, blockNumber)];
                    case 6:
                        exploitationStageIdentifiedVictims = _d.sent();
                        filteredExploitationStageVictims = exploitationStageVictims.filter(function (victim) {
                            return Object.keys(exploitationStageIdentifiedVictims).includes(victim.address);
                        });
                        exploitationStageVictimsWithConfidence = {};
                        // Add confidence property to the exploitation stage victims objects
                        for (_c = 0, filteredExploitationStageVictims_1 = filteredExploitationStageVictims; _c < filteredExploitationStageVictims_1.length; _c++) {
                            victim = filteredExploitationStageVictims_1[_c];
                            exploitationStageVictimsWithConfidence[victim.address] = __assign(__assign({}, exploitationStageIdentifiedVictims[victim.address]), { confidence: victim.confidence });
                        }
                        return [2 /*return*/, {
                                exploitationStage: exploitationStageVictimsWithConfidence,
                                preparationStage: preparationStageVictimsWithConfidence,
                            }];
                }
            });
        }); };
        // Extract the keys or set default values
        var _a = apiKeys.ethplorerApiKey, ethplorerApiKey = _a === void 0 ? "freekey" : _a, _b = apiKeys.luabaseApiKey, luabaseApiKey = _b === void 0 ? "" : _b, _c = apiKeys.moralisApiKey, moralisApiKey = _c === void 0 ? "" : _c, _d = apiKeys.etherscanApiKey, etherscanApiKey = _d === void 0 ? "YourApiKeyToken" : _d, _e = apiKeys.optimisticEtherscanApiKey, optimisticEtherscanApiKey = _e === void 0 ? "YourApiKeyToken" : _e, _f = apiKeys.bscscanApiKey, bscscanApiKey = _f === void 0 ? "YourApiKeyToken" : _f, _g = apiKeys.polygonscanApiKey, polygonscanApiKey = _g === void 0 ? "YourApiKeyToken" : _g, _h = apiKeys.fantomscanApiKey, fantomscanApiKey = _h === void 0 ? "YourApiKeyToken" : _h, _j = apiKeys.arbiscanApiKey, arbiscanApiKey = _j === void 0 ? "YourApiKeyToken" : _j, _k = apiKeys.snowtraceApiKey, snowtraceApiKey = _k === void 0 ? "YourApiKeyToken" : _k;
        // Set the keys
        restApis["luabaseKey"] = luabaseApiKey;
        restApis["ethplorerKey"] = ethplorerApiKey;
        restApis["moralisKey"] = moralisApiKey;
        etherscanApis[1].key = etherscanApiKey;
        etherscanApis[10].key = optimisticEtherscanApiKey;
        etherscanApis[56].key = bscscanApiKey;
        etherscanApis[137].key = polygonscanApiKey;
        etherscanApis[250].key = fantomscanApiKey;
        etherscanApis[42161].key = arbiscanApiKey;
        etherscanApis[43114].key = snowtraceApiKey;
        _this.addressesExtractor = new addresses_extractor_1.default(provider);
        _this.init = false;
        _this.protocols = [];
        _this.getProtocols();
        _this.victimOccurrences = {};
        _this.maxOccurrences = 0;
        _this.isContractCache = new lru_cache_1.default({ max: 10000 });
        return _this;
    }
    return VictimIdentifier;
}(token_info_fetcher_1.default));
exports.default = VictimIdentifier;
