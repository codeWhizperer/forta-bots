"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ethers_1 = require("ethers");
var token_info_fetcher_1 = __importDefault(require("./token.info.fetcher"));
var constants_1 = require("./constants");
var utils_1 = require("ethers/lib/utils");
var test_1 = require("../../../test");
var __1 = require("../..");
var node_fetch_1 = __importDefault(require("node-fetch"));
jest.mock("node-fetch");
var Response = jest.requireActual("node-fetch").Response;
// [blockNumber, balance]
var TEST_BALANCES = [
    [10, ethers_1.BigNumber.from(70)],
    [20, ethers_1.BigNumber.from(1001)],
    [25, ethers_1.BigNumber.from(1000)],
    [30, ethers_1.BigNumber.from(100)],
    [40, ethers_1.BigNumber.from(120)],
    [50, ethers_1.BigNumber.from(240)],
];
// [blockNumber, symbol]
var TEST_SYMBOLS = [
    [10, "AAA"],
    [20, "BBB"],
    [30, "CCC"],
    [40, "DDD"],
    [50, "EEE"],
];
// [blockNumber, name]
var TEST_NAMES = [
    [10, "tokenAAA"],
    [20, "tokenBBB"],
    [30, "tokenCCC"],
    [40, "tokenDDD"],
    [50, "tokenEEE"],
];
// [blockNumber, name]
var TEST_DECIMALS = [
    [10, 18],
    [20, 6],
    [30, 31],
    [40, 11],
    [50, 9],
];
// [blockNumber, token, totalSupply]
var TEST_TOTAL_SUPPLIES = [
    [10, (0, __1.createAddress)("0xa1"), ethers_1.BigNumber.from(100)],
    [20, (0, __1.createAddress)("0xa2"), ethers_1.BigNumber.from(1000)],
    [30, (0, __1.createAddress)("0xa3"), ethers_1.BigNumber.from(10000)],
    [40, (0, __1.createAddress)("0xa4"), ethers_1.BigNumber.from(100000)],
    [50, (0, __1.createAddress)("0xa5"), ethers_1.BigNumber.from(1000000)],
];
var TEST_BLOCK = 120;
var PROTOCOL_ADDRESS = (0, __1.createAddress)("0xa1");
var tokenAddress = (0, __1.createAddress)("0xa2");
var TOKEN_IFACE = new utils_1.Interface(constants_1.TOKEN_ABI);
var MKR_TOKEN_IFACE = new utils_1.Interface(constants_1.MKR_TOKEN_ABI);
var testKeys = {
    ethplorerApiKey: "Test1",
    luabaseApiKey: "Test2",
    moralisApiKey: "Test3",
    etherscanApiKey: "Test4",
    optimisticEtherscanApiKey: "Test5",
    bscscanApiKey: "Test6",
    polygonscanApiKey: "Test7",
    fantomscanApiKey: "Test8",
    arbiscanApiKey: "Test9",
    snowtraceApiKey: "Test10",
};
describe("TokenInfoFetcher tests suite", function () {
    var mockProvider = new test_1.MockEthersProvider();
    var fetcher;
    beforeAll(function () {
        fetcher = new token_info_fetcher_1.default(mockProvider, testKeys);
    });
    afterEach(function () {
        jest.clearAllMocks();
    });
    it("should fetch balance and use cache correctly", function () { return __awaiter(void 0, void 0, void 0, function () {
        var _i, TEST_BALANCES_1, _a, block, balance, fetchedBalance, _b, TEST_BALANCES_2, _c, block, balance, fetchedBalance;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _i = 0, TEST_BALANCES_1 = TEST_BALANCES;
                    _d.label = 1;
                case 1:
                    if (!(_i < TEST_BALANCES_1.length)) return [3 /*break*/, 4];
                    _a = TEST_BALANCES_1[_i], block = _a[0], balance = _a[1];
                    mockProvider.addCallTo(tokenAddress, block, TOKEN_IFACE, "balanceOf", {
                        inputs: [PROTOCOL_ADDRESS],
                        outputs: [balance],
                    });
                    return [4 /*yield*/, fetcher.getBalance(block, PROTOCOL_ADDRESS, tokenAddress)];
                case 2:
                    fetchedBalance = _d.sent();
                    expect(fetchedBalance).toStrictEqual(balance);
                    _d.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4:
                    expect(mockProvider.call).toBeCalledTimes(6);
                    // clear mockProvider to use cache
                    mockProvider.clear();
                    _b = 0, TEST_BALANCES_2 = TEST_BALANCES;
                    _d.label = 5;
                case 5:
                    if (!(_b < TEST_BALANCES_2.length)) return [3 /*break*/, 8];
                    _c = TEST_BALANCES_2[_b], block = _c[0], balance = _c[1];
                    return [4 /*yield*/, fetcher.getBalance(block, PROTOCOL_ADDRESS, tokenAddress)];
                case 6:
                    fetchedBalance = _d.sent();
                    expect(fetchedBalance).toStrictEqual(balance);
                    _d.label = 7;
                case 7:
                    _b++;
                    return [3 /*break*/, 5];
                case 8:
                    expect(mockProvider.call).toBeCalledTimes(6);
                    mockProvider.clear();
                    return [2 /*return*/];
            }
        });
    }); });
    it("should fetch total supply and use cache correctly", function () { return __awaiter(void 0, void 0, void 0, function () {
        var _i, TEST_TOTAL_SUPPLIES_1, _a, block, token, totalSupply, fetchedTotalSupply, _b, TEST_TOTAL_SUPPLIES_2, _c, block, token, totalSupply, fetchedTotalSupply;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _i = 0, TEST_TOTAL_SUPPLIES_1 = TEST_TOTAL_SUPPLIES;
                    _d.label = 1;
                case 1:
                    if (!(_i < TEST_TOTAL_SUPPLIES_1.length)) return [3 /*break*/, 4];
                    _a = TEST_TOTAL_SUPPLIES_1[_i], block = _a[0], token = _a[1], totalSupply = _a[2];
                    mockProvider.addCallTo(token, block, TOKEN_IFACE, "totalSupply", {
                        inputs: [],
                        outputs: [totalSupply],
                    });
                    return [4 /*yield*/, fetcher.getTotalSupply(block, token)];
                case 2:
                    fetchedTotalSupply = _d.sent();
                    expect(fetchedTotalSupply).toStrictEqual(totalSupply);
                    _d.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4:
                    expect(mockProvider.call).toBeCalledTimes(5);
                    // clear mockProvider to use cache
                    mockProvider.clear();
                    _b = 0, TEST_TOTAL_SUPPLIES_2 = TEST_TOTAL_SUPPLIES;
                    _d.label = 5;
                case 5:
                    if (!(_b < TEST_TOTAL_SUPPLIES_2.length)) return [3 /*break*/, 8];
                    _c = TEST_TOTAL_SUPPLIES_2[_b], block = _c[0], token = _c[1], totalSupply = _c[2];
                    return [4 /*yield*/, fetcher.getTotalSupply(block, token)];
                case 6:
                    fetchedTotalSupply = _d.sent();
                    expect(fetchedTotalSupply).toStrictEqual(totalSupply);
                    _d.label = 7;
                case 7:
                    _b++;
                    return [3 /*break*/, 5];
                case 8:
                    expect(mockProvider.call).toBeCalledTimes(5);
                    mockProvider.clear();
                    return [2 /*return*/];
            }
        });
    }); });
    it("should fetch ERC20 and native token symbol and use cache correctly", function () { return __awaiter(void 0, void 0, void 0, function () {
        var chainId, _i, TEST_SYMBOLS_1, _a, block, symbol, fetchedSymbol_1, fetchedSymbol, mkrLikefetchedSymbol, fetchedName, _b, TEST_SYMBOLS_2, _c, block, symbol, fetchedSymbol_2;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    chainId = 1;
                    _i = 0, TEST_SYMBOLS_1 = TEST_SYMBOLS;
                    _d.label = 1;
                case 1:
                    if (!(_i < TEST_SYMBOLS_1.length)) return [3 /*break*/, 4];
                    _a = TEST_SYMBOLS_1[_i], block = _a[0], symbol = _a[1];
                    mockProvider.addCallTo(tokenAddress, block, TOKEN_IFACE, "symbol", {
                        inputs: [],
                        outputs: [symbol],
                    });
                    return [4 /*yield*/, fetcher.getSymbolOrName(chainId, block, tokenAddress)];
                case 2:
                    fetchedSymbol_1 = _d.sent();
                    expect(fetchedSymbol_1).toStrictEqual(symbol);
                    _d.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4:
                    expect(mockProvider.call).toBeCalledTimes(5);
                    return [4 /*yield*/, fetcher.getSymbolOrName(chainId, TEST_BLOCK, "native")];
                case 5:
                    fetchedSymbol = _d.sent();
                    expect(fetchedSymbol).toStrictEqual("ETH");
                    // MKR-like
                    mockProvider.addCallTo(tokenAddress, TEST_BLOCK, MKR_TOKEN_IFACE, "symbol", {
                        inputs: [],
                        outputs: [ethers_1.ethers.utils.formatBytes32String("MKR")],
                    });
                    return [4 /*yield*/, fetcher.getSymbolOrName(chainId, TEST_BLOCK, tokenAddress)];
                case 6:
                    mkrLikefetchedSymbol = _d.sent();
                    expect(mkrLikefetchedSymbol).toStrictEqual("MKR");
                    // Fetching name if symbol is not defined
                    mockProvider.addCallTo((0, __1.createAddress)("0x1234"), TEST_BLOCK, TOKEN_IFACE, "name", {
                        inputs: [],
                        outputs: [TEST_NAMES[0][1]],
                    });
                    return [4 /*yield*/, fetcher.getSymbolOrName(chainId, TEST_BLOCK, (0, __1.createAddress)("0x1234"))];
                case 7:
                    fetchedName = _d.sent();
                    expect(fetchedName).toStrictEqual(TEST_NAMES[0][1]);
                    // clear mockProvider to use cache
                    mockProvider.clear();
                    _b = 0, TEST_SYMBOLS_2 = TEST_SYMBOLS;
                    _d.label = 8;
                case 8:
                    if (!(_b < TEST_SYMBOLS_2.length)) return [3 /*break*/, 11];
                    _c = TEST_SYMBOLS_2[_b], block = _c[0], symbol = _c[1];
                    return [4 /*yield*/, fetcher.getSymbolOrName(chainId, block, tokenAddress)];
                case 9:
                    fetchedSymbol_2 = _d.sent();
                    expect(fetchedSymbol_2).toStrictEqual(symbol);
                    _d.label = 10;
                case 10:
                    _b++;
                    return [3 /*break*/, 8];
                case 11: return [2 /*return*/];
            }
        });
    }); });
    it("should fetch token name and use cache correctly", function () { return __awaiter(void 0, void 0, void 0, function () {
        var _i, TEST_NAMES_1, _a, block, name_1, fetchedName, _b, TEST_NAMES_2, _c, block, name_2, fetchedName;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _i = 0, TEST_NAMES_1 = TEST_NAMES;
                    _d.label = 1;
                case 1:
                    if (!(_i < TEST_NAMES_1.length)) return [3 /*break*/, 4];
                    _a = TEST_NAMES_1[_i], block = _a[0], name_1 = _a[1];
                    mockProvider.addCallTo(tokenAddress, block, TOKEN_IFACE, "name", {
                        inputs: [],
                        outputs: [name_1],
                    });
                    return [4 /*yield*/, fetcher.getName(block, tokenAddress)];
                case 2:
                    fetchedName = _d.sent();
                    expect(fetchedName).toStrictEqual(name_1);
                    _d.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4:
                    expect(mockProvider.call).toBeCalledTimes(5);
                    // clear mockProvider to use cache
                    mockProvider.clear();
                    _b = 0, TEST_NAMES_2 = TEST_NAMES;
                    _d.label = 5;
                case 5:
                    if (!(_b < TEST_NAMES_2.length)) return [3 /*break*/, 8];
                    _c = TEST_NAMES_2[_b], block = _c[0], name_2 = _c[1];
                    return [4 /*yield*/, fetcher.getName(block, tokenAddress)];
                case 6:
                    fetchedName = _d.sent();
                    expect(fetchedName).toStrictEqual(name_2);
                    _d.label = 7;
                case 7:
                    _b++;
                    return [3 /*break*/, 5];
                case 8: return [2 /*return*/];
            }
        });
    }); });
    it("should fetch token decimals and use cache correctly", function () { return __awaiter(void 0, void 0, void 0, function () {
        var _i, TEST_DECIMALS_1, _a, block, decimals, fetchedDecimals, _b, TEST_DECIMALS_2, _c, block, decimals, fetchedDecimals;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _i = 0, TEST_DECIMALS_1 = TEST_DECIMALS;
                    _d.label = 1;
                case 1:
                    if (!(_i < TEST_DECIMALS_1.length)) return [3 /*break*/, 4];
                    _a = TEST_DECIMALS_1[_i], block = _a[0], decimals = _a[1];
                    mockProvider.addCallTo(tokenAddress, block, TOKEN_IFACE, "decimals", {
                        inputs: [],
                        outputs: [decimals],
                    });
                    return [4 /*yield*/, fetcher.getDecimals(block, tokenAddress)];
                case 2:
                    fetchedDecimals = _d.sent();
                    expect(fetchedDecimals).toStrictEqual(decimals);
                    _d.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4:
                    expect(mockProvider.call).toBeCalledTimes(5);
                    // clear mockProvider to use cache
                    mockProvider.clear();
                    _b = 0, TEST_DECIMALS_2 = TEST_DECIMALS;
                    _d.label = 5;
                case 5:
                    if (!(_b < TEST_DECIMALS_2.length)) return [3 /*break*/, 8];
                    _c = TEST_DECIMALS_2[_b], block = _c[0], decimals = _c[1];
                    return [4 /*yield*/, fetcher.getDecimals(block, tokenAddress)];
                case 6:
                    fetchedDecimals = _d.sent();
                    expect(fetchedDecimals).toStrictEqual(decimals);
                    _d.label = 7;
                case 7:
                    _b++;
                    return [3 /*break*/, 5];
                case 8: return [2 /*return*/];
            }
        });
    }); });
    it("should fetch the value in USD correctly", function () { return __awaiter(void 0, void 0, void 0, function () {
        var chainId, mockFetch, fetchedNativeValue, fetchedTokenValue;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    chainId = 1;
                    mockFetch = jest.mocked(node_fetch_1.default, true);
                    mockFetch.mockResolvedValueOnce(new Response(JSON.stringify({ ethereum: { usd: 1.2 } })));
                    return [4 /*yield*/, fetcher.getValueInUsd(TEST_BLOCK, chainId, "2000000000000000000", "native")];
                case 1:
                    fetchedNativeValue = _a.sent();
                    expect(fetchedNativeValue).toStrictEqual(2.4);
                    mockFetch.mockResolvedValueOnce(new Response(JSON.stringify({ "0x00000000000000000000000000000000000000a2": { usd: 3 } })));
                    mockProvider.addCallTo(tokenAddress, TEST_BLOCK, TOKEN_IFACE, "decimals", {
                        inputs: [],
                        outputs: [18],
                    });
                    return [4 /*yield*/, fetcher.getValueInUsd(TEST_BLOCK, chainId, "4000000000000000000", tokenAddress)];
                case 2:
                    fetchedTokenValue = _a.sent();
                    expect(fetchedTokenValue).toStrictEqual(12);
                    return [2 /*return*/];
            }
        });
    }); });
    it("should fetch the token holders correctly", function () { return __awaiter(void 0, void 0, void 0, function () {
        var nativeHolders, mockFetch, uniswapV3Holders, erc20Holders;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fetcher.getHolders("native", "Tag")];
                case 1:
                    nativeHolders = _a.sent();
                    expect(nativeHolders).toStrictEqual([]);
                    mockFetch = jest.mocked(node_fetch_1.default, true);
                    mockFetch.mockResolvedValueOnce(new Response(JSON.stringify({
                        data: {
                            positions: [{ owner: (0, __1.createAddress)("0xffaabb") }, { owner: (0, __1.createAddress)("0xffaabbcc") }],
                        },
                    })));
                    return [4 /*yield*/, fetcher.getHolders(tokenAddress, "Uniswap V3")];
                case 2:
                    uniswapV3Holders = _a.sent();
                    expect(uniswapV3Holders).toStrictEqual([(0, __1.createAddress)("0xffaabb"), (0, __1.createAddress)("0xffaabbcc")]);
                    mockFetch.mockResolvedValueOnce(new Response(JSON.stringify({
                        holders: [
                            { address: (0, __1.createAddress)("0xaabb"), balance: 33, share: 28 },
                            { address: (0, __1.createAddress)("0xaabbcc"), balance: 233, share: 228 },
                        ],
                    })));
                    return [4 /*yield*/, fetcher.getHolders(tokenAddress, "Not Uniswap V3")];
                case 3:
                    erc20Holders = _a.sent();
                    expect(erc20Holders).toStrictEqual([(0, __1.createAddress)("0xaabb"), (0, __1.createAddress)("0xaabbcc")]);
                    return [2 /*return*/];
            }
        });
    }); });
});
