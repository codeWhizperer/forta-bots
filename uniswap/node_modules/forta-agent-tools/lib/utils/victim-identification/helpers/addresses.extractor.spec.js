"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var jest_when_1 = require("jest-when");
var forta_agent_1 = require("forta-agent");
var addresses_extractor_1 = __importDefault(require("./addresses.extractor"));
var test_1 = require("../../../test");
var __1 = require("../..");
var opcodesToReturn = [];
// mocking the evm module
jest.mock("evm", function () {
    return {
        EVM: jest.fn().mockImplementation(function () {
            return {
                getOpcodes: function () {
                    return opcodesToReturn;
                },
            };
        }),
    };
});
var MockEthersProviderExtended = /** @class */ (function (_super) {
    __extends(MockEthersProviderExtended, _super);
    function MockEthersProviderExtended() {
        var _this = _super.call(this) || this;
        _this.getCode = jest.fn();
        return _this;
    }
    MockEthersProviderExtended.prototype.setCode = function (address, code, blockNumber) {
        (0, jest_when_1.when)(this.getCode).calledWith(address, blockNumber).mockReturnValue(Promise.resolve(code));
        return this;
    };
    return MockEthersProviderExtended;
}(test_1.MockEthersProvider));
var TestTransactionEventExtended = /** @class */ (function (_super) {
    __extends(TestTransactionEventExtended, _super);
    function TestTransactionEventExtended() {
        return _super.call(this) || this;
    }
    TestTransactionEventExtended.prototype.addTraces2 = function () {
        var _a;
        var traceProps = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            traceProps[_i] = arguments[_i];
        }
        var toTrace = function (props) {
            var _a, _b, _c, _d, _e, _f;
            if (!props.function) {
                return {
                    action: {
                        to: (_a = props.to) === null || _a === void 0 ? void 0 : _a.toLowerCase(),
                        from: (_b = props.from) === null || _b === void 0 ? void 0 : _b.toLowerCase(),
                        value: props.value,
                    },
                    result: {
                        address: (_c = props.address) === null || _c === void 0 ? void 0 : _c.toLowerCase(),
                    },
                    type: props.type,
                    traceAddress: props.traceAddress,
                };
            }
            var functionFragment = forta_agent_1.ethers.utils.FunctionFragment.from(forta_agent_1.ethers.utils.Fragment.from(props.function));
            var iface = new forta_agent_1.ethers.utils.Interface([functionFragment]);
            return {
                action: {
                    to: (_d = props.to) === null || _d === void 0 ? void 0 : _d.toLowerCase(),
                    from: (_e = props.from) === null || _e === void 0 ? void 0 : _e.toLowerCase(),
                    input: iface.encodeFunctionData(functionFragment, props.arguments),
                    value: props.value,
                },
                result: {
                    address: (_f = props.address) === null || _f === void 0 ? void 0 : _f.toLowerCase(),
                    output: iface.encodeFunctionResult(functionFragment, props.output),
                },
                type: props.type,
                traceAddress: props.traceAddress,
            };
        };
        (_a = this.traces).push.apply(_a, traceProps.map(toTrace));
        return this;
    };
    return TestTransactionEventExtended;
}(test_1.TestTransactionEvent));
describe("Addresses Extractor tests suite", function () {
    var mockProvider = new MockEthersProviderExtended();
    var addressExtractor;
    beforeEach(function () {
        addressExtractor = new addresses_extractor_1.default(mockProvider);
    });
    it("should return an empty set if there is no contract created", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, addresses;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mockTxEvent = new test_1.TestTransactionEvent();
                    return [4 /*yield*/, addressExtractor.extractAddresses(mockTxEvent)];
                case 1:
                    addresses = _a.sent();
                    expect(addresses.size).toBe(0);
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return an empty set if there is a contract deployed but it doesn't contain any storage or opcode addresses", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, createdContractAddress, i, addresses;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mockTxEvent = new test_1.TestTransactionEvent().setTo("").setBlock(12100);
                    createdContractAddress = "0xBd770416a3345F91E4B34576cb804a576fa48EB1";
                    // Return no extracted addresses from storage
                    for (i = 0; i < 20; i++) {
                        mockProvider.addStorage(createdContractAddress, i, 12100, "0x0000000000000000000000000000000000000000000000000000000000000000");
                    }
                    return [4 /*yield*/, addressExtractor.extractAddresses(mockTxEvent)];
                case 1:
                    addresses = _a.sent();
                    expect(addresses.size).toBe(0);
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return storage addresses correctly when there's no txEvent.to address defined", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, createdContractAddress, extractedAddress1, extractedAddress2, i, addresses;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    opcodesToReturn = [];
                    mockTxEvent = new test_1.TestTransactionEvent().setTo("").setBlock(100);
                    createdContractAddress = "0xBd770416a3345F91E4B34576cb804a576fa48EB1";
                    extractedAddress1 = (0, __1.createAddress)("0x888");
                    extractedAddress2 = (0, __1.createAddress)("0x9999");
                    // mock the provider's getStorageAt method to return the extracted addresses at the first storage slot of the created contract
                    mockProvider.addStorage(createdContractAddress, 0, 100, extractedAddress1);
                    mockProvider.setCode(extractedAddress1, "0x1234", 100);
                    mockProvider.addStorage(createdContractAddress, 1, 100, extractedAddress2);
                    mockProvider.setCode(extractedAddress2, "0x1234", 100);
                    for (i = 2; i < 20; i++) {
                        mockProvider.addStorage(createdContractAddress, i, 100, "0x0000000000000000000000000000000000000000000000000000000000000000");
                    }
                    return [4 /*yield*/, addressExtractor.extractAddresses(mockTxEvent)];
                case 1:
                    addresses = _a.sent();
                    expect(addresses.size).toBe(2);
                    expect(addresses.has(forta_agent_1.ethers.utils.getAddress(extractedAddress1))).toBeTruthy();
                    expect(addresses.has(forta_agent_1.ethers.utils.getAddress(extractedAddress2))).toBeTruthy();
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return storage addresses correctly when there's a contract defined in the traces", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, createdContractAddress, extractedAddress1, extractedAddress2, i, addresses;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    opcodesToReturn = [];
                    mockTxEvent = new TestTransactionEventExtended();
                    createdContractAddress = (0, __1.createAddress)("0x789");
                    extractedAddress1 = (0, __1.createAddress)("0x11888");
                    extractedAddress2 = (0, __1.createAddress)("0x11999");
                    mockTxEvent
                        .addTraces2({
                        from: (0, __1.createAddress)("0x123"),
                        address: createdContractAddress,
                        type: "create",
                    })
                        .setFrom((0, __1.createAddress)("0x123"))
                        .setBlock(15500);
                    // mock the provider's getStorageAt method to return the extracted addresses at the first storage slot of the created contract
                    mockProvider.addStorage(createdContractAddress, 0, 15500, extractedAddress1);
                    mockProvider.setCode(extractedAddress1, "0x1234", 15500);
                    mockProvider.addStorage(createdContractAddress, 1, 15500, extractedAddress2);
                    mockProvider.setCode(extractedAddress2, "0x1234", 15500);
                    for (i = 2; i < 20; i++) {
                        mockProvider.addStorage(createdContractAddress, i, 15500, "0x0000000000000000000000000000000000000000000000000000000000000000");
                    }
                    return [4 /*yield*/, addressExtractor.extractAddresses(mockTxEvent)];
                case 1:
                    addresses = _a.sent();
                    expect(addresses.size).toBe(2);
                    expect(addresses.has(forta_agent_1.ethers.utils.getAddress(extractedAddress1))).toBeTruthy();
                    expect(addresses.has(forta_agent_1.ethers.utils.getAddress(extractedAddress2))).toBeTruthy();
                    return [2 /*return*/];
            }
        });
    }); });
    it("should extract opcode addresses correctly", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, createdContractAddress, opcodeExtractedAddress, i, addresses;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mockTxEvent = new test_1.TestTransactionEvent().setTo("").setBlock(22100);
                    createdContractAddress = "0xBd770416a3345F91E4B34576cb804a576fa48EB1";
                    opcodeExtractedAddress = (0, __1.createAddress)("0x22222");
                    opcodesToReturn = [{ pushData: opcodeExtractedAddress.slice(2) }];
                    // Return no extracted addresses from storage
                    for (i = 0; i < 20; i++) {
                        mockProvider.addStorage(createdContractAddress, i, 22100, "0x0000000000000000000000000000000000000000000000000000000000000000");
                    }
                    // get the code of the created contract to be able to extract the opcodes
                    mockProvider.setCode(createdContractAddress, "0x12aa3456", 22100);
                    // mock the provider's getCode method to return the USDC address as the first opcode
                    mockProvider.setCode(opcodeExtractedAddress, "0x2112aa312", 22100);
                    return [4 /*yield*/, addressExtractor.extractAddresses(mockTxEvent)];
                case 1:
                    addresses = _a.sent();
                    expect(addresses.size).toBe(1);
                    expect(addresses.has(forta_agent_1.ethers.utils.getAddress(opcodeExtractedAddress))).toBeTruthy();
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return both storage and opcode addresses if both have been found", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, createdContractAddress, extractedWETHAddress, opcodeUSDCAddress, i, addresses;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mockTxEvent = new test_1.TestTransactionEvent().setTo("").setBlock(100);
                    createdContractAddress = "0xBd770416a3345F91E4B34576cb804a576fa48EB1";
                    extractedWETHAddress = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
                    opcodeUSDCAddress = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
                    opcodesToReturn = [{ pushData: "A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" }]; // USDC address without the "0x" as it would have been returned from the evm's Buffer
                    // mock the provider's getStorageAt method to return the WETH address at the first storage slot of the created contract
                    mockProvider.addStorage(createdContractAddress, 0, 100, extractedWETHAddress);
                    mockProvider.setCode(extractedWETHAddress, "0x1234", 100);
                    for (i = 1; i < 20; i++) {
                        mockProvider.addStorage(createdContractAddress, i, 100, "0x0000000000000000000000000000000000000000000000000000000000000000");
                    }
                    // get the code of the created contract to be able to extract the opcodes
                    mockProvider.setCode(createdContractAddress, "0x123456", 100);
                    // mock the provider's getCode method to return the USDC address as the first opcode
                    mockProvider.setCode(opcodeUSDCAddress, "0x12345612312", 100);
                    return [4 /*yield*/, addressExtractor.extractAddresses(mockTxEvent)];
                case 1:
                    addresses = _a.sent();
                    expect(addresses.size).toBe(2);
                    expect(addresses.has(forta_agent_1.ethers.utils.getAddress(extractedWETHAddress))).toBeTruthy();
                    expect(addresses.has(forta_agent_1.ethers.utils.getAddress(opcodeUSDCAddress))).toBeTruthy();
                    return [2 /*return*/];
            }
        });
    }); });
    //   it("should return storage addresses", async () => {
    //     const address = "0x1234567890123456789012345678901234567890";
    //   });
});
