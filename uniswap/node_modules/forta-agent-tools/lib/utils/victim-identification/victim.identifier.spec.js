"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var victim_identifier_1 = __importDefault(require("./victim.identifier"));
var node_fetch_1 = __importDefault(require("node-fetch"));
var utils_1 = require("ethers/lib/utils");
var jest_when_1 = require("jest-when");
var constants_1 = require("./helpers/constants");
var forta_agent_1 = require("forta-agent");
var __1 = require("..");
var test_1 = require("../../test");
var mockAlertsResponse;
var mockGetAlerts;
jest.mock("forta-agent", function () {
    var original = jest.requireActual("forta-agent");
    return __assign(__assign({}, original), { getAlerts: (mockGetAlerts = jest.fn(function () { return Promise.resolve(mockAlertsResponse); })) });
});
jest.mock("node-fetch");
var Response = jest.requireActual("node-fetch").Response;
var opcodesToReturn = [];
// mocking the evm module
jest.mock("evm", function () {
    return {
        EVM: jest.fn().mockImplementation(function () {
            return {
                getOpcodes: function () {
                    return opcodesToReturn;
                },
            };
        }),
    };
});
var TestTransactionEventExtended = /** @class */ (function (_super) {
    __extends(TestTransactionEventExtended, _super);
    function TestTransactionEventExtended() {
        return _super.call(this) || this;
    }
    TestTransactionEventExtended.prototype.addTraces2 = function () {
        var _a;
        var traceProps = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            traceProps[_i] = arguments[_i];
        }
        var toTrace = function (props) {
            var _a, _b, _c, _d, _e, _f;
            if (!props.function) {
                return {
                    action: {
                        to: (_a = props.to) === null || _a === void 0 ? void 0 : _a.toLowerCase(),
                        from: (_b = props.from) === null || _b === void 0 ? void 0 : _b.toLowerCase(),
                        value: props.value,
                        callType: props.callType,
                    },
                    result: {
                        address: (_c = props.address) === null || _c === void 0 ? void 0 : _c.toLowerCase(),
                    },
                    type: props.type,
                    traceAddress: props.traceAddress,
                };
            }
            var functionFragment = forta_agent_1.ethers.utils.FunctionFragment.from(forta_agent_1.ethers.utils.Fragment.from(props.function));
            var iface = new forta_agent_1.ethers.utils.Interface([functionFragment]);
            return {
                action: {
                    to: (_d = props.to) === null || _d === void 0 ? void 0 : _d.toLowerCase(),
                    from: (_e = props.from) === null || _e === void 0 ? void 0 : _e.toLowerCase(),
                    input: iface.encodeFunctionData(functionFragment, props.arguments),
                    value: props.value,
                    callType: props.callType,
                },
                result: {
                    address: (_f = props.address) === null || _f === void 0 ? void 0 : _f.toLowerCase(),
                    output: iface.encodeFunctionResult(functionFragment, props.output),
                },
                type: props.type,
                traceAddress: props.traceAddress,
            };
        };
        (_a = this.traces).push.apply(_a, traceProps.map(toTrace));
        return this;
    };
    return TestTransactionEventExtended;
}(test_1.TestTransactionEvent));
var MockEthersProviderExtended = /** @class */ (function (_super) {
    __extends(MockEthersProviderExtended, _super);
    function MockEthersProviderExtended() {
        var _this = _super.call(this) || this;
        _this.getCode = jest.fn();
        return _this;
    }
    MockEthersProviderExtended.prototype.setCode = function (address, code, blockNumber) {
        (0, jest_when_1.when)(this.getCode).calledWith(address, blockNumber).mockReturnValue(Promise.resolve(code));
        return this;
    };
    MockEthersProviderExtended.prototype.addStorageExtended = function (contract, slot, block, result) {
        (0, jest_when_1.when)(this.getStorageAt).calledWith(contract, slot, block).mockReturnValue(Promise.resolve(result));
        return this;
    };
    return MockEthersProviderExtended;
}(test_1.MockEthersProvider));
var testKeys = {
    ethplorerApiKey: "Test1",
    luabaseApiKey: "Test2",
    moralisApiKey: "Test3",
    etherscanApiKey: "Test4",
    optimisticEtherscanApiKey: "Test5",
    bscscanApiKey: "Test6",
    polygonscanApiKey: "Test7",
    fantomscanApiKey: "Test8",
    arbiscanApiKey: "Test9",
    snowtraceApiKey: "Test10",
};
var fetchProtocols = function () {
    var mockFetch = jest.mocked(node_fetch_1.default, true);
    mockFetch.mockResolvedValueOnce(Promise.resolve(new Response(JSON.stringify([
        { slug: "uniswap", url: "uniswap.org", twitter: "Uniswap" },
        { slug: "sushiswap", url: "sushiswap.org", twitter: "SushiSwap" },
        { slug: "victim1234", url: "victim1234.org", twitter: "Victim1234Twitter" },
        { slug: "victim5678", url: "victim5678.org", twitter: "Victim5678Twitter" },
    ]))));
};
describe("Victim Identifier tests suite", function () {
    var mockProvider = new MockEthersProviderExtended();
    var victimIdentifier;
    beforeEach(function () {
        mockGetAlerts.mockClear();
        mockProvider.clear();
        fetchProtocols();
        victimIdentifier = new victim_identifier_1.default(mockProvider, testKeys);
    });
    it("should return an empty record if there is no victim found", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, victims;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mockTxEvent = new test_1.TestTransactionEvent().setBlock(123);
                    mockProvider.setNetwork(1);
                    mockAlertsResponse = {
                        alerts: [
                            {
                                metadata: {
                                    address1: (0, __1.createAddress)("0x1234"),
                                    address2: (0, __1.createAddress)("0x5678"),
                                    address2Again: (0, __1.createAddress)("0x5678"),
                                },
                            },
                        ],
                        pageInfo: {
                            hasNextPage: false,
                            endCursor: {
                                alertId: "1234",
                                blockNumber: 0,
                            },
                        },
                    };
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(mockGetAlerts).toHaveBeenCalled();
                    expect(victims).toEqual({ exploitationStage: {}, preparationStage: {} });
                    return [2 /*return*/];
            }
        });
    }); });
    it("should not fetch the past alerts twice in the same block", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, victims, mockTxEvent2, victims2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mockTxEvent = new test_1.TestTransactionEvent().setBlock(21123);
                    mockProvider.setNetwork(1);
                    mockAlertsResponse = {
                        alerts: [
                            {
                                metadata: {
                                    address1: (0, __1.createAddress)("0x1234"),
                                    address2: (0, __1.createAddress)("0x5678"),
                                    address2Again: (0, __1.createAddress)("0x5678"),
                                },
                            },
                        ],
                        pageInfo: {
                            hasNextPage: false,
                            endCursor: {
                                alertId: "1234",
                                blockNumber: 0,
                            },
                        },
                    };
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(mockGetAlerts).toHaveBeenCalledTimes(1);
                    expect(victims).toEqual({ exploitationStage: {}, preparationStage: {} });
                    mockGetAlerts.mockClear();
                    mockTxEvent2 = new test_1.TestTransactionEvent().setBlock(21123);
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent2)];
                case 2:
                    victims2 = _a.sent();
                    expect(mockGetAlerts).not.toHaveBeenCalled();
                    expect(victims2).toEqual({ exploitationStage: {}, preparationStage: {} });
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return preparation stage victims correctly when the tag can be found", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, createdContractAddress, extractedAddress1, extractedAddress2, i, fetch, Response, callCount, victims;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mockTxEvent = new test_1.TestTransactionEvent().setBlock(44123).setTo("");
                    mockProvider.setNetwork(1);
                    mockAlertsResponse = {
                        alerts: [
                            {
                                metadata: __assign(__assign({}, Object.assign.apply(Object, __spreadArray([{}], Array.from({ length: 10 }, function (_, i) {
                                    var _a;
                                    return (_a = {},
                                        _a["address".concat(i)] = (0, __1.createAddress)("0x1234"),
                                        _a);
                                }), false))), { address10: (0, __1.createAddress)("0x5678") }),
                            },
                        ],
                        pageInfo: {
                            hasNextPage: false,
                            endCursor: {
                                alertId: "1234",
                                blockNumber: 0,
                            },
                        },
                    };
                    createdContractAddress = "0xBd770416a3345F91E4B34576cb804a576fa48EB1";
                    extractedAddress1 = (0, __1.createAddress)("0x1234");
                    extractedAddress2 = (0, __1.createAddress)("0x5678");
                    // mock the provider's getStorageAt method to return the extracted addresses at the first storage slot of the created contract
                    mockProvider.addStorage(createdContractAddress, 0, 44123, extractedAddress1);
                    mockProvider.setCode(extractedAddress1, "0x1234", 44123);
                    mockProvider.addStorage(createdContractAddress, 1, 44123, extractedAddress2);
                    mockProvider.setCode(extractedAddress2, "0x5678", 44123);
                    for (i = 2; i < 20; i++) {
                        mockProvider.addStorage(createdContractAddress, i, 44123, "0x0000000000000000000000000000000000000000000000000000000000000000");
                    }
                    jest.mock("node-fetch");
                    fetch = require("node-fetch");
                    Response = jest.requireActual("node-fetch").Response;
                    callCount = 0;
                    fetch.mockImplementation(function () {
                        callCount += 1;
                        if (callCount === 1) {
                            // First call is to the Luabase DB for the 1st extracted contract address
                            return Promise.resolve(new Response(JSON.stringify({
                                data: [{ tag: "Victim5678" }],
                            })));
                        }
                        else if (callCount === 2) {
                            // As the tag is fetched from Luabase on the previous call, the 2nd call is to Ethplorer API in regards to the holders
                            return Promise.resolve(new Response(JSON.stringify({
                                holders: [
                                    { address: (0, __1.createAddress)("0x22aabb"), balance: 133, share: 28 },
                                    { address: (0, __1.createAddress)("0x33aabbcc"), balance: 4233, share: 228 },
                                ],
                            })));
                        }
                        else if (callCount === 3) {
                            // Same process for the 2nd extracted contract address
                            return Promise.resolve(new Response(JSON.stringify({
                                data: [{ tag: "Victim1234" }],
                            })));
                        }
                        else if (callCount === 4) {
                            return Promise.resolve(new Response(JSON.stringify({
                                holders: [
                                    { address: (0, __1.createAddress)("0x44aabb"), balance: 33, share: 28 },
                                    { address: (0, __1.createAddress)("0x55aabbcc"), balance: 233, share: 228 },
                                ],
                            })));
                        }
                    });
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(victims).toStrictEqual({
                        exploitationStage: {},
                        preparationStage: {
                            "0x0000000000000000000000000000000000005678": {
                                holders: ["0x000000000000000000000000000000000022aabb", "0x0000000000000000000000000000000033aabbcc"],
                                protocolTwitter: "Victim5678Twitter",
                                protocolUrl: "victim5678.org",
                                tag: "Victim5678",
                                confidence: 0.6,
                            },
                            "0x0000000000000000000000000000000000001234": {
                                holders: ["0x000000000000000000000000000000000044aabb", "0x0000000000000000000000000000000055aabbcc"],
                                protocolTwitter: "Victim1234Twitter",
                                protocolUrl: "victim1234.org",
                                tag: "Victim1234",
                                confidence: 0,
                            },
                        },
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return a preparation stage victim when the victim contract's creator tag can be found", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, createdContractAddress, extractedAddress1, i, fetch, Response, callCount, victims;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mockTxEvent = new test_1.TestTransactionEvent().setBlock(144123).setTo("");
                    mockProvider.setNetwork(1);
                    mockAlertsResponse = {
                        alerts: [
                            {
                                metadata: {
                                    address1: (0, __1.createAddress)("0x1234"),
                                    address1again: (0, __1.createAddress)("0x1234"),
                                    address2: (0, __1.createAddress)("0x5678"),
                                },
                            },
                        ],
                        pageInfo: {
                            hasNextPage: false,
                            endCursor: {
                                alertId: "1234",
                                blockNumber: 0,
                            },
                        },
                    };
                    createdContractAddress = "0xBd770416a3345F91E4B34576cb804a576fa48EB1";
                    extractedAddress1 = (0, __1.createAddress)("0x1234");
                    mockProvider.addStorage(createdContractAddress, 0, 144123, extractedAddress1);
                    mockProvider.setCode(extractedAddress1, "0x1234", 144123);
                    for (i = 1; i < 20; i++) {
                        mockProvider.addStorage(createdContractAddress, i, 144123, "0x0000000000000000000000000000000000000000000000000000000000000000");
                    }
                    jest.mock("node-fetch");
                    fetch = require("node-fetch");
                    Response = jest.requireActual("node-fetch").Response;
                    callCount = 0;
                    fetch.mockImplementation(function () {
                        callCount += 1;
                        if (callCount === 1) {
                            return Promise.resolve(new Response(JSON.stringify({})));
                        }
                        else if (callCount === 2) {
                            return Promise.resolve(new Response(JSON.stringify({
                                message: "OOOK",
                                result: [{ contractCreator: (0, __1.createAddress)("0xccccb") }],
                            })));
                        }
                        else if (callCount === 3) {
                            return Promise.resolve(new Response(JSON.stringify({
                                data: [{ tag: "Uniswap V3: Deployer" }],
                            })));
                        }
                        else if (callCount === 4) {
                            return Promise.resolve(new Response(JSON.stringify({
                                data: {
                                    positions: [{ owner: (0, __1.createAddress)("0x22aabb") }, { owner: (0, __1.createAddress)("0x33aabbcc") }],
                                },
                            })));
                        }
                    });
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(victims).toStrictEqual({
                        exploitationStage: {},
                        preparationStage: {
                            "0x0000000000000000000000000000000000001234": {
                                protocolUrl: "https://uniswap.org/",
                                protocolTwitter: "Uniswap",
                                tag: "Uniswap V3",
                                holders: ["0x000000000000000000000000000000000022aabb", "0x0000000000000000000000000000000033aabbcc"],
                                confidence: 0,
                            },
                        },
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return a preparation stage victim when the victim is an ERC20 token", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, createdContractAddress, extractedAddress1, i, fetch, Response, callCount, TOKEN_IFACE, victims;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mockTxEvent = new test_1.TestTransactionEvent().setBlock(344123).setTo("");
                    mockProvider.setNetwork(1);
                    mockAlertsResponse = {
                        alerts: [
                            {
                                metadata: {
                                    address1: (0, __1.createAddress)("0x1234"),
                                    address1again: (0, __1.createAddress)("0x1234"),
                                    address2: (0, __1.createAddress)("0x5678"),
                                },
                            },
                        ],
                        pageInfo: {
                            hasNextPage: false,
                            endCursor: {
                                alertId: "1234",
                                blockNumber: 0,
                            },
                        },
                    };
                    createdContractAddress = "0xBd770416a3345F91E4B34576cb804a576fa48EB1";
                    extractedAddress1 = (0, __1.createAddress)("0x1234");
                    mockProvider.addStorage(createdContractAddress, 0, 344123, extractedAddress1);
                    mockProvider.setCode(extractedAddress1, "0x1234", 344123);
                    for (i = 1; i < 20; i++) {
                        mockProvider.addStorage(createdContractAddress, i, 344123, "0x0000000000000000000000000000000000000000000000000000000000000000");
                    }
                    jest.mock("node-fetch");
                    fetch = require("node-fetch");
                    Response = jest.requireActual("node-fetch").Response;
                    callCount = 0;
                    fetch.mockImplementation(function () {
                        callCount += 1;
                        if (callCount === 1) {
                            // Luabase doesn't return the tag
                            return Promise.resolve(new Response(JSON.stringify({})));
                        }
                        else if (callCount === 2) {
                            // Block explorer call to fetch the contract creator address "fails"
                            return Promise.resolve(new Response(JSON.stringify({
                                message: "NOTOK",
                            })));
                        }
                    });
                    TOKEN_IFACE = new utils_1.Interface(constants_1.TOKEN_ABI);
                    // Not implementating a mock implementation of the call to the Ethereum lists DB implies a call, so it then tries to fetch the token's name
                    mockProvider.addCallTo(extractedAddress1, 344123, TOKEN_IFACE, "name", {
                        inputs: [],
                        outputs: ["DOGE"],
                    });
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(victims).toStrictEqual({
                        exploitationStage: {},
                        preparationStage: {
                            "0x0000000000000000000000000000000000001234": {
                                protocolUrl: "",
                                protocolTwitter: "",
                                tag: "DOGE",
                                holders: [],
                                confidence: 0,
                            },
                        },
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return a preparation stage victim when the victim's tag can be fetched by the contract name", function () { return __awaiter(void 0, void 0, void 0, function () {
        var mockTxEvent, createdContractAddress, extractedAddress1, i, fetch, Response, callCount, victims;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mockTxEvent = new test_1.TestTransactionEvent().setBlock(444123).setTo("");
                    mockProvider.setNetwork(1);
                    mockAlertsResponse = {
                        alerts: [
                            {
                                metadata: {
                                    address1: (0, __1.createAddress)("0x1234"),
                                    address1again: (0, __1.createAddress)("0x1234"),
                                    address2: (0, __1.createAddress)("0x5678"),
                                },
                            },
                        ],
                        pageInfo: {
                            hasNextPage: false,
                            endCursor: {
                                alertId: "1234",
                                blockNumber: 0,
                            },
                        },
                    };
                    createdContractAddress = "0xBd770416a3345F91E4B34576cb804a576fa48EB1";
                    extractedAddress1 = (0, __1.createAddress)("0x1234");
                    mockProvider.addStorage(createdContractAddress, 0, 444123, extractedAddress1);
                    mockProvider.setCode(extractedAddress1, "0x1234", 444123);
                    for (i = 1; i < 20; i++) {
                        mockProvider.addStorage(createdContractAddress, i, 444123, "0x0000000000000000000000000000000000000000000000000000000000000000");
                    }
                    mockProvider.addStorageExtended(extractedAddress1, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc", 444123, "0x000000000000000000000000587969add789c13f64bcc34ff253bd9bfb78f38a");
                    jest.mock("node-fetch");
                    fetch = require("node-fetch");
                    Response = jest.requireActual("node-fetch").Response;
                    callCount = 0;
                    fetch.mockImplementation(function () {
                        callCount += 1;
                        if (callCount === 1) {
                            // Luabase doesn't return the tag
                            return Promise.resolve(new Response(JSON.stringify({})));
                        }
                        else if (callCount === 2) {
                            // Block explorer call to fetch the contract creator address "fails"
                            return Promise.resolve(new Response(JSON.stringify({
                                message: "NOTOK",
                            })));
                        }
                        else if (callCount === 3) {
                            // Not mocking an ERC20 symbol/name call implying a failed call, so it then fetches the contract name
                            return Promise.resolve(new Response(JSON.stringify({
                                message: "OOOK",
                                result: [{ ContractName: "proxyyyyyy" }],
                            })));
                        }
                        else if (callCount === 4) {
                            // Call to the block explorer API to fetch the implementation contract name
                            return Promise.resolve(new Response(JSON.stringify({
                                message: "OOOK",
                                result: [{ ContractName: "VerifiedContract22" }],
                            })));
                        }
                    });
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(victims).toStrictEqual({
                        exploitationStage: {},
                        preparationStage: {
                            "0x0000000000000000000000000000000000001234": {
                                protocolUrl: "",
                                protocolTwitter: "",
                                tag: "VerifiedContract22",
                                holders: [],
                                confidence: 0,
                            },
                        },
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return an exploitation stage victim when its tag is found, exploited via an ERC20 Transfer", function () { return __awaiter(void 0, void 0, void 0, function () {
        var TRANSFER_IFACE, TEST_TOKEN, FROM, TO, event, data, mockTxEvent, fetch, Response, callCount, TOKEN_IFACE, victims;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    TRANSFER_IFACE = new utils_1.Interface([constants_1.ERC20_TRANSFER_EVENT]);
                    TEST_TOKEN = (0, __1.createAddress)("0x2222");
                    FROM = (0, __1.createAddress)("0x1234");
                    TO = (0, __1.createAddress)("0x5678");
                    event = TRANSFER_IFACE.getEvent("Transfer");
                    data = [FROM, TO, forta_agent_1.ethers.BigNumber.from("3424324324423423")];
                    mockTxEvent = new test_1.TestTransactionEvent().setBlock(5444123).addEventLog(event, TEST_TOKEN, data);
                    mockProvider.setCode(FROM, "0x1", 5444123);
                    jest.mock("node-fetch");
                    fetch = require("node-fetch");
                    Response = jest.requireActual("node-fetch").Response;
                    callCount = 0;
                    fetch.mockImplementation(function () {
                        callCount += 1;
                        if (callCount === 1) {
                            // In exploitation stage victims cases, the first call is to fetch the token price. Not adding a mock implementation for the rest of the calls implies that the tag ended up being fetched through the ERC20 token's symbol
                            return Promise.resolve(new Response(JSON.stringify({
                                "0x0000000000000000000000000000000000002222": { usd: 52354234 },
                            })));
                        }
                    });
                    TOKEN_IFACE = new utils_1.Interface(constants_1.TOKEN_ABI);
                    mockProvider.addCallTo(TEST_TOKEN, 5444123, TOKEN_IFACE, "decimals", {
                        inputs: [],
                        outputs: [18],
                    });
                    mockProvider.addCallTo(FROM, 5444123, TOKEN_IFACE, "symbol", {
                        inputs: [],
                        outputs: ["HEY"],
                    });
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(victims).toStrictEqual({
                        exploitationStage: {
                            "0x0000000000000000000000000000000000001234": {
                                holders: [],
                                protocolTwitter: "",
                                protocolUrl: "",
                                tag: "HEY",
                                confidence: 0.4,
                            },
                        },
                        preparationStage: {},
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return an exploitation stage victim when its tag is found, exploited via an ERC20 Transfer when the USD value can't be fetched but the balance change is over 10% of the total supply", function () { return __awaiter(void 0, void 0, void 0, function () {
        var TRANSFER_IFACE, TEST_TOKEN, FROM, TO, event, data, mockTxEvent, TOKEN_IFACE, victims;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    TRANSFER_IFACE = new utils_1.Interface([constants_1.ERC20_TRANSFER_EVENT]);
                    TEST_TOKEN = (0, __1.createAddress)("0x2222");
                    FROM = (0, __1.createAddress)("0x1234");
                    TO = (0, __1.createAddress)("0x5678");
                    event = TRANSFER_IFACE.getEvent("Transfer");
                    data = [FROM, TO, forta_agent_1.ethers.BigNumber.from("3424324324423423")];
                    mockTxEvent = new test_1.TestTransactionEvent().setBlock(5444123).addEventLog(event, TEST_TOKEN, data);
                    mockProvider.setCode(FROM, "0x1", 5444123);
                    TOKEN_IFACE = new utils_1.Interface(constants_1.TOKEN_ABI);
                    mockProvider.addCallTo(TEST_TOKEN, 5444123, TOKEN_IFACE, "totalSupply", {
                        inputs: [],
                        outputs: [forta_agent_1.ethers.BigNumber.from("4424324324423423")], // over 5% of the total supply
                    });
                    mockProvider.addCallTo(TEST_TOKEN, 5444123, TOKEN_IFACE, "decimals", {
                        inputs: [],
                        outputs: [18],
                    });
                    mockProvider.addCallTo(FROM, 5444123, TOKEN_IFACE, "symbol", {
                        inputs: [],
                        outputs: ["LpToken"],
                    });
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(victims).toStrictEqual({
                        exploitationStage: {
                            "0x0000000000000000000000000000000000001234": {
                                holders: [],
                                protocolTwitter: "",
                                protocolUrl: "",
                                tag: "LpToken",
                                confidence: 1,
                            },
                        },
                        preparationStage: {},
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return an exploitation stage victim when its tag is found, exploited via a native transfer", function () { return __awaiter(void 0, void 0, void 0, function () {
        var FROM, TO, mockTxEvent, fetch, Response, callCount, TOKEN_IFACE, victims;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    FROM = (0, __1.createAddress)("0x1234");
                    TO = (0, __1.createAddress)("0x5678");
                    mockTxEvent = new TestTransactionEventExtended();
                    mockTxEvent
                        .addTraces2({
                        from: FROM,
                        to: TO,
                        value: forta_agent_1.ethers.BigNumber.from("3242323423424324324423423").toString(),
                        callType: "call",
                    })
                        .setBlock(51444123);
                    mockProvider.setCode(FROM, "0x1", 51444123);
                    jest.mock("node-fetch");
                    fetch = require("node-fetch");
                    Response = jest.requireActual("node-fetch").Response;
                    callCount = 0;
                    fetch.mockImplementation(function () {
                        callCount += 1;
                        if (callCount === 1) {
                            // In exploitation stage victims cases, the first call is to fetch the token price. Not adding a mock implementation for the rest of the calls implies that the tag ended up being fetched through the ERC20 token's symbol
                            return Promise.resolve(new Response(JSON.stringify({
                                ethereum: { usd: 9999 },
                            })));
                        }
                    });
                    TOKEN_IFACE = new utils_1.Interface(constants_1.TOKEN_ABI);
                    mockProvider.addCallTo(FROM, 51444123, TOKEN_IFACE, "symbol", {
                        inputs: [],
                        outputs: ["AWW"],
                    });
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(victims).toStrictEqual({
                        exploitationStage: {
                            "0x0000000000000000000000000000000000001234": {
                                holders: [],
                                protocolTwitter: "",
                                protocolUrl: "",
                                tag: "AWW",
                                confidence: 1,
                            },
                        },
                        preparationStage: {},
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return two victims on the exploitation stage", function () { return __awaiter(void 0, void 0, void 0, function () {
        var TRANSFER_IFACE, TEST_TOKEN, FROM, TO, event, data, FROM_NATIVE, TO_NATIVE, mockTxEvent, fetch, Response, callCount, TOKEN_IFACE, victims;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    TRANSFER_IFACE = new utils_1.Interface([constants_1.ERC20_TRANSFER_EVENT]);
                    TEST_TOKEN = (0, __1.createAddress)("0x2222");
                    FROM = (0, __1.createAddress)("0x1234");
                    TO = (0, __1.createAddress)("0x5678");
                    event = TRANSFER_IFACE.getEvent("Transfer");
                    data = [FROM, TO, forta_agent_1.ethers.BigNumber.from("3424324324423423")];
                    FROM_NATIVE = (0, __1.createAddress)("0x4444");
                    TO_NATIVE = (0, __1.createAddress)("0x3333");
                    mockTxEvent = new TestTransactionEventExtended()
                        .addTraces2({
                        from: FROM_NATIVE,
                        to: TO_NATIVE,
                        value: forta_agent_1.ethers.BigNumber.from("13242323423424324324423423").toString(),
                        callType: "call",
                    })
                        .setBlock(99)
                        .addEventLog(event, TEST_TOKEN, data);
                    mockProvider.setCode(FROM, "0x1", 99);
                    jest.mock("node-fetch");
                    fetch = require("node-fetch");
                    Response = jest.requireActual("node-fetch").Response;
                    callCount = 0;
                    fetch.mockImplementation(function () {
                        callCount += 1;
                        if (callCount === 1) {
                            // First call to fetch the token's price
                            return Promise.resolve(new Response(JSON.stringify({
                                "0x0000000000000000000000000000000000002222": { usd: 752354234 },
                            })));
                        }
                        else if (callCount === 2) {
                            // Mock a failed call to fetch the price of the same token for the case of the receiver of the ERC20 transfer, as it's not needed
                            return Promise.reject(new Response());
                        }
                        else if (callCount === 3) {
                            // Fetch the price of the native token in regards to the native token transfer
                            return Promise.resolve(new Response(JSON.stringify({
                                ethereum: { usd: 19999 },
                            })));
                        }
                    });
                    TOKEN_IFACE = new utils_1.Interface(constants_1.TOKEN_ABI);
                    mockProvider.addCallTo(TEST_TOKEN, 99, TOKEN_IFACE, "decimals", {
                        inputs: [],
                        outputs: [18],
                    });
                    // By not mocking any of the rest calls, the tag is fetched using the ERC20 token's symbol method.
                    mockProvider.addCallTo(FROM, 99, TOKEN_IFACE, "symbol", {
                        inputs: [],
                        outputs: ["ERC20LostERC20"],
                    });
                    mockProvider.addCallTo(FROM_NATIVE, 99, TOKEN_IFACE, "symbol", {
                        inputs: [],
                        outputs: ["ERC20LostNative"],
                    });
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(victims).toStrictEqual({
                        exploitationStage: {
                            "0x0000000000000000000000000000000000001234": {
                                holders: [],
                                protocolTwitter: "",
                                protocolUrl: "",
                                tag: "ERC20LostERC20",
                                confidence: 1,
                            },
                            "0x0000000000000000000000000000000000004444": {
                                holders: [],
                                protocolTwitter: "",
                                protocolUrl: "",
                                tag: "ERC20LostNative",
                                confidence: 1,
                            },
                        },
                        preparationStage: {},
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it("should return victims both from the exploitation and the preparation stage", function () { return __awaiter(void 0, void 0, void 0, function () {
        var TRANSFER_FROM, TRANSFER_TO, createdContractAddress, extractedAddress, mockTxEvent, i, fetch, Response, callCount, TOKEN_IFACE, victims;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    TRANSFER_FROM = (0, __1.createAddress)("0x1234");
                    TRANSFER_TO = (0, __1.createAddress)("0x5678");
                    createdContractAddress = (0, __1.createAddress)("0x789");
                    extractedAddress = (0, __1.createAddress)("0x11888");
                    mockAlertsResponse = {
                        alerts: [
                            {
                                metadata: {
                                    address1: (0, __1.createAddress)("0x1234"),
                                    address1again: (0, __1.createAddress)("0x1234"),
                                    address2: (0, __1.createAddress)("0x5678"),
                                },
                            },
                        ],
                        pageInfo: {
                            hasNextPage: false,
                            endCursor: {
                                alertId: "1234",
                                blockNumber: 0,
                            },
                        },
                    };
                    mockTxEvent = new TestTransactionEventExtended();
                    mockTxEvent
                        .addTraces2({
                        from: (0, __1.createAddress)("0x123"),
                        address: createdContractAddress,
                        type: "create",
                    })
                        .addTraces2({
                        from: TRANSFER_FROM,
                        to: TRANSFER_TO,
                        value: forta_agent_1.ethers.BigNumber.from("3242323423424324324423423").toString(),
                        callType: "call",
                    })
                        .setFrom((0, __1.createAddress)("0x123"))
                        .setBlock(122);
                    mockProvider.addStorage(createdContractAddress, 0, 122, extractedAddress);
                    mockProvider.setCode(extractedAddress, "0x1234", 122);
                    for (i = 1; i < 20; i++) {
                        mockProvider.addStorage(createdContractAddress, i, 122, "0x0000000000000000000000000000000000000000000000000000000000000000");
                    }
                    mockProvider.setCode(TRANSFER_FROM, "0x1", 122);
                    jest.mock("node-fetch");
                    fetch = require("node-fetch");
                    Response = jest.requireActual("node-fetch").Response;
                    callCount = 0;
                    fetch.mockImplementation(function () {
                        callCount += 1;
                        if (callCount === 1) {
                            // Fetch the price of the native token in regards to the exploitation stage victim
                            return Promise.resolve(new Response(JSON.stringify({
                                ethereum: { usd: 9999 },
                            })));
                        }
                        else if (callCount === 2) {
                            // Fetch the price of the native token for the case of the receiver in order to keep the correct order of the calls (Alternatively, 3 [due to the retries] failed could have been used)
                            return Promise.resolve(new Response(JSON.stringify({
                                ethereum: { usd: 9999 },
                            })));
                        }
                        else if (callCount === 3) {
                            // Preparation Stage Victim: Call to Luabase DB
                            return Promise.resolve(new Response(JSON.stringify({
                                data: [{ tag: "Victim5678" }],
                            })));
                        }
                        else if (callCount === 4) {
                            // Preparation Stage Victim: Call to the Ethplorer API
                            return Promise.resolve(new Response(JSON.stringify({
                                holders: [
                                    { address: (0, __1.createAddress)("0x22aabb"), balance: 133, share: 28 },
                                    {
                                        address: (0, __1.createAddress)("0x33aabbcc"),
                                        balance: 4233,
                                        share: 228,
                                    },
                                ],
                            })));
                        }
                        else if (callCount === 5) {
                            // Exploitation Stage Victim: Failed call to Luabase DB
                            return Promise.reject(new Response());
                        }
                        else if (callCount === 6) {
                            // Exploitation Stage Victim: Failed call to get the contract creator address
                            return Promise.reject(new Response());
                        }
                        else if (callCount === 7) {
                            // Exploitation Stage Victim: Failed call to get the token holders
                            return Promise.reject(new Response());
                        }
                    });
                    TOKEN_IFACE = new utils_1.Interface(constants_1.TOKEN_ABI);
                    mockProvider.addCallTo(TRANSFER_FROM, 122, TOKEN_IFACE, "symbol", {
                        inputs: [],
                        outputs: ["AWW"],
                    });
                    return [4 /*yield*/, victimIdentifier.getIdentifiedVictims(mockTxEvent)];
                case 1:
                    victims = _a.sent();
                    expect(victims).toStrictEqual({
                        exploitationStage: {
                            "0x0000000000000000000000000000000000001234": {
                                holders: [],
                                protocolTwitter: "",
                                protocolUrl: "",
                                tag: "AWW",
                                confidence: 1,
                            },
                        },
                        preparationStage: {
                            "0x0000000000000000000000000000000000011888": {
                                holders: ["0x000000000000000000000000000000000022aabb", "0x0000000000000000000000000000000033aabbcc"],
                                protocolTwitter: "Victim5678Twitter",
                                protocolUrl: "victim5678.org",
                                tag: "Victim5678",
                                confidence: 1,
                            },
                        },
                    });
                    return [2 /*return*/];
            }
        });
    }); });
});
